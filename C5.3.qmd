# Ejemplo en R

## Base de datos

**Referencia del dataset:** Fisher, R. (1936). Iris \[Dataset\]. UCI Machine Learning Repository. <https://doi.org/10.24432/C56C76>

**Acceso a recursos:** El script completo con el ejemplo desarrollado y la base de datos IRIS pueden descargarse en el siguiente repositorio:

A continuación, se presenta un conjunto de datos correspondientes a la longitud del pétalo (en cm) de 150 flores de la especie *Iris*, organizados en formato matricial para facilitar su visualización y análisis. Estos datos serán utilizados para ilustrar el cálculo de estadísticos descriptivos para datos agrupados, siguiendo las metodologías propuestas en la sección aterior.

|     |     |     |     |     |     |     |     |     |     |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
| 1.4 | 1.4 | 1.3 | 1.5 | 1.4 | 1.7 | 1.4 | 1.5 | 1.4 | 1.5 |
| 1.5 | 1.6 | 1.4 | 1.1 | 1.2 | 1.5 | 1.3 | 1.4 | 1.7 | 1.5 |
| 1.7 | 1.5 | 1.0 | 1.7 | 1.9 | 1.6 | 1.6 | 1.5 | 1.4 | 1.6 |
| 1.6 | 1.5 | 1.5 | 1.4 | 1.5 | 1.2 | 1.3 | 1.4 | 1.3 | 1.5 |
| 1.3 | 1.3 | 1.3 | 1.6 | 1.9 | 1.4 | 1.6 | 1.4 | 1.5 | 1.4 |
| 4.7 | 4.5 | 4.9 | 4.0 | 4.6 | 4.5 | 4.7 | 3.3 | 4.6 | 3.9 |
| 3.5 | 4.2 | 4.0 | 4.7 | 3.6 | 4.4 | 4.5 | 4.1 | 4.5 | 3.9 |
| 4.8 | 4.0 | 4.9 | 4.7 | 4.3 | 4.4 | 4.8 | 5.0 | 4.5 | 3.5 |
| 3.8 | 3.7 | 3.9 | 5.1 | 4.5 | 4.5 | 4.7 | 4.4 | 4.1 | 4.0 |
| 4.4 | 4.6 | 4.0 | 3.3 | 4.2 | 4.2 | 4.2 | 4.3 | 3.0 | 4.1 |
| 6.0 | 5.1 | 5.9 | 5.6 | 5.8 | 6.6 | 4.5 | 6.3 | 5.8 | 6.1 |
| 5.1 | 5.3 | 5.5 | 5.0 | 5.1 | 5.3 | 5.5 | 6.7 | 6.9 | 5.0 |
| 5.7 | 4.9 | 6.7 | 4.9 | 5.7 | 6.0 | 4.8 | 4.9 | 5.6 | 5.8 |
| 6.1 | 6.4 | 5.6 | 5.1 | 5.6 | 6.1 | 5.6 | 5.5 | 4.8 | 5.4 |
| 5.6 | 5.1 | 5.1 | 5.9 | 5.7 | 5.2 | 5.0 | 5.2 | 5.4 | 5.1 |

## Carga y Preparación de Datos

```{r}
# Cargar el dataset iris
data(iris)

# Extraer la variable longitud de pétalo
longitud_petalo <- iris$Petal.Length

```

## Construcción de la Tabla de Frecuencias 

### Determinación de Parámetros Básicos

```{r}
# Función para calcular parámetros de agrupamiento
calcular_parametros_agrupamiento <- function(datos) {
  n <- length(datos)
  x_min <- min(datos)
  x_max <- max(datos)
  rango <- x_max - x_min
  
  # Regla de Sturges para número de clases
  k <- round(1 + 3.322 * log10(n))
  
  # Amplitud de clase
  amplitud <- rango / k
  
  return(list(
    n = n,
    x_min = x_min,
    x_max = x_max,
    rango = rango,
    k = k,
    amplitud = amplitud
  ))
}

# Aplicar función
parametros <- calcular_parametros_agrupamiento(longitud_petalo)
parametros
```

### Construcción de Intervalos y Cálculo de Frecuencias

```{r}
# Función para construir tabla de frecuencias
construir_tabla_frecuencias <- function(datos, parametros) {
  # Crear límites de clase
  limite_inferior <- seq(parametros$x_min, 
                        parametros$x_max - parametros$amplitud, 
                        by = parametros$amplitud)
  limite_superior <- seq(parametros$x_min + parametros$amplitud, 
                        parametros$x_max, 
                        by = parametros$amplitud)
  
  # Ajustar último límite superior
  limite_superior[length(limite_superior)] <- parametros$x_max
  
  # Calcular marcas de clase
  marca_clase <- (limite_inferior + limite_superior) / 2
  
  # Calcular frecuencias absolutas usando cut()
  intervalos <- cut(datos, 
                   breaks = c(limite_inferior, parametros$x_max),
                   include.lowest = TRUE,
                   right = FALSE)
  frecuencia_absoluta <- as.numeric(table(intervalos))
  
  # Calcular frecuencias derivadas
  frecuencia_relativa <- frecuencia_absoluta / parametros$n
  frecuencia_acumulada <- cumsum(frecuencia_absoluta)
  fi_xi <- frecuencia_absoluta * marca_clase
  fi_xi2 <- frecuencia_absoluta * (marca_clase^2)
  
  # Crear tabla
  tabla <- data.frame(
    Clase = 1:parametros$k,
    Limite_Inferior = limite_inferior,
    Limite_Superior = limite_superior,
    Marca_Clase = round(marca_clase, 3),
    Frecuencia_Absoluta = frecuencia_absoluta,
    Frecuencia_Relativa = round(frecuencia_relativa, 4),
    Frecuencia_Acumulada = frecuencia_acumulada,
    fi_xi = round(fi_xi, 3),
    fi_xi2 = round(fi_xi2, 3)
  )
  
  return(tabla)
}

# Construir tabla de frecuencias
tabla_freq <- construir_tabla_frecuencias(longitud_petalo, parametros)

# Mostrar tabla
tabla_freq
```

## Medidas de Tendencia Central

```{r}
# Función para calcular medidas de tendencia central
calcular_tendencia_central <- function(tabla, parametros) {
  # Media aritmética
  media <- sum(tabla$fi_xi) / parametros$n
  
  # Mediana
  posicion_mediana <- parametros$n / 2
  clase_mediana <- which(tabla$Frecuencia_Acumulada >= posicion_mediana)[1]
  fa_anterior <- ifelse(clase_mediana == 1, 0, 
                       tabla$Frecuencia_Acumulada[clase_mediana - 1])
  
  mediana <- tabla$Limite_Inferior[clase_mediana] + 
            ((posicion_mediana - fa_anterior) / 
             tabla$Frecuencia_Absoluta[clase_mediana]) * parametros$amplitud
  
  # Moda
  clase_modal <- which.max(tabla$Frecuencia_Absoluta)
  d1 <- tabla$Frecuencia_Absoluta[clase_modal] - 
       ifelse(clase_modal == 1, 0, 
              tabla$Frecuencia_Absoluta[clase_modal - 1])
  d2 <- tabla$Frecuencia_Absoluta[clase_modal] - 
       ifelse(clase_modal == parametros$k, 0, 
              tabla$Frecuencia_Absoluta[clase_modal + 1])
  
  moda <- tabla$Limite_Inferior[clase_modal] + 
         (d1 / (d1 + d2)) * parametros$amplitud
  
  return(list(media = media, mediana = mediana, moda = moda))
}

# Calcular medidas
tendencia <- calcular_tendencia_central(tabla_freq, parametros)

# Mostrar resultados 
tendencia
```

## Medidas de Dispersión

```{r}
# Función para calcular medidas de dispersión
calcular_dispersion <- function(tabla, parametros, media) {
  # Rango aproximado
  rango_aprox <- tabla$Limite_Superior[parametros$k] - 
                tabla$Limite_Inferior[1]
  
  # Varianza
  varianza <- (sum(tabla$fi_xi2) - (sum(tabla$fi_xi)^2 / parametros$n)) / 
             (parametros$n - 1)
  
  # Desviación estándar
  desviacion_std <- sqrt(varianza)
  
  # Coeficiente de variación
  cv <- (desviacion_std / media) * 100
  
  return(list(
    rango = rango_aprox,
    varianza = varianza,
    desviacion_std = desviacion_std,
    cv = cv
  ))
}

# Calcular medidas de dispersión
dispersion <- calcular_dispersion(tabla_freq, parametros, tendencia$media)

# Mostrar los resultados
dispersion
```

## Medidas de Posición Relativa

```{r}
# Función para calcular cuartiles y percentiles
calcular_posicion_relativa <- function(tabla, parametros, posicion, tipo = "cuartil") {
  if (tipo == "cuartil") {
    pos_valor <- posicion * parametros$n / 4
  } else if (tipo == "percentil") {
    pos_valor <- posicion * parametros$n / 100
  }
  
  clase_objetivo <- which(tabla$Frecuencia_Acumulada >= pos_valor)[1]
  fa_anterior <- ifelse(clase_objetivo == 1, 0, 
                       tabla$Frecuencia_Acumulada[clase_objetivo - 1])
  
  valor <- tabla$Limite_Inferior[clase_objetivo] + 
          ((pos_valor - fa_anterior) / 
           tabla$Frecuencia_Absoluta[clase_objetivo]) * parametros$amplitud
  
  return(valor)
}

# Calcular Q1 y P80
Q1 <- calcular_posicion_relativa(tabla_freq, parametros, 1, "cuartil")
P80 <- calcular_posicion_relativa(tabla_freq, parametros, 80, "percentil")

# Mostrar resultados
Q1
P80
```
